# 高频面试题

### 1. 拿到一个项目整体优化思路

当拿到一个项目时，可以从以下几个方面考虑整体优化：

1. 性能优化：分析项目的性能瓶颈，包括加载速度、响应时间等方面。可以采用压缩代码、合并文件、懒加载、异步加载等技术来提高页面加载速度和性能。
2. 代码优化：对项目中的代码进行审查，主要关注冗余代码、重复逻辑、低效操作等问题，并进行重构和优化，提高代码质量和可维护性。
3. 图片优化：优化图片大小、格式选择、懒加载、延迟加载等方式来减少网络传输和提高页面加载速度。
4. 缓存机制：通过使用浏览器缓存、CDN缓存等手段来减少服务器压力和提高用户访问速度。
5. 前端打包工具优化：如Webpack、Rollup等，通过配置优化打包的输出结果、代码分割、按需加载等，减小打包体积和提高打包速度。
6. 响应式设计：针对不同设备和屏幕尺寸进行适配，保证项目在不同平台上有良好的展示效果。
7. 安全性优化：加强项目的安全性，对用户输入进行验证和过滤，防范常见的安全攻击。

### 2. 浏览器兼容从哪些方面下手等等之类的

浏览器兼容性是前端开发中需要考虑的一个重要问题。下面是一些从不同方面入手解决浏览器兼容性问题的方法：

1. 特性检测：使用特性检测（Feature Detection）来判断浏览器是否支持某个功能或属性，根据不同的情况提供替代方案或降级处理。
2. 使用CSS Reset或Normalize.css：使用CSS Reset可以消除不同浏览器间的默认样式差异，使得页面在各个浏览器中更加统一。Normalize.css则能够保留有用的默认样式，修复浏览器之间的一些不一致行为。
3. 使用Polyfill或Shim：通过引入Polyfill或Shim库来填充浏览器缺失的功能，例如ES6+语法、HTML5 API等。
4. 优雅降级和渐进增强：针对不同浏览器版本和能力，逐步增加功能和交互效果，确保基本功能在所有浏览器中都可用，而高级功能则根据浏览器支持情况进行增强。
5. 根据数据统计进行分析：通过收集用户访问数据，了解用户使用的浏览器类型和版本分布情况，重点关注市场份额较大或特定用户群体使用的浏览器进行兼容性优化。
6. 使用CSS前缀和垫片：对于部分CSS属性和新特性，使用浏览器前缀（如-webkit、-moz）来适配不同浏览器，并使用垫片（如autoprefixer）自动添加浏览器前缀。

### 3. 在实际项目中浏览器的适配是如何处理的

在实际项目中，浏览器适配通常通过以下方式进行处理：

1. 选择目标浏览器：根据项目需求和用户群体特征，选择需要支持的目标浏览器版本范围。可以参考市在实际项目中，浏览器的适配可以通过以下几种方式进行处理：
2. 浏览器嗅探：使用JavaScript等技术来检测用户所使用的浏览器类型和版本，并根据不同的浏览器进行适配处理。可以使用现有的库或框架如Modernizr来进行浏览器特性检测和嗅探。
3. 兼容代码编写：根据目标浏览器的不同特性和支持程度，编写兼容性代码。这包括使用特性检测、选择合适的Polyfill或Shim来填补浏览器的功能缺失，以及提供替代方案或降级处理。例如，使用flexbox布局时，可以添加浏览器前缀，并提供备用的布局方案。
4. CSS hack：针对不同浏览器的CSS样式差异，可以使用CSS hack技术进行适配。但需要注意的是，CSS hack可能会导致代码可读性和可维护性下降，因此应尽量避免过多使用。更好的方式是使用CSS预处理器如Sass或Less来生成兼容不同浏览器的CSS样式。
5. 媒体查询：使用响应式设计的原则，在CSS中使用媒体查询来适配不同的屏幕尺寸和设备。通过设置不同的CSS规则，可以根据屏幕宽度、高度等属性来调整页面布局和显示效果。
6. 浏览器测试：在项目开发过程中，进行多浏览器测试是必要的。通过使用各种主流浏览器（如Chrome、Firefox、Safari、Edge等）来测试项目在不同浏览器中的兼容性，并及时修复和调整样式或代码问题。

总的来说，在实际项目中，浏览器适配需要综合考虑目标浏览器、功能需求、用户群体等因素，并使用一系列技术手段来保证项目在不同浏览器中的良好表现和用户体验。

### 4. Webpack原理？Webpack相关优化手段

Webpack是一个现代化的前端打包工具，它可以将多个模块打包成静态资源文件。以下是Webpack的一些基本原理和相关优化手段：

1. 基本原理：

- - 入口起点：Webpack会从指定的入口文件开始，通过解析依赖关系构建整个项目的依赖图。
- 模块解析：Webpack支持多种模块系统（如CommonJS、AMD、ES6模块），通过相应的加载器和插件来转换和解析模块。
- 打包输出：Webpack根据配置将所有模块打包成最终的静态资源文件，可在浏览器中加载执行。

1. 优化手段：

- - Code Splitting（代码拆分）：将代码拆分成多个bundle，实现按需加载，减小初始加载体积，提高页面加载速度。
- Tree Shaking（摇树优化）：通过静态代码分析，删除未使用的代码，减少打包体积。
- 懒加载（Lazy Loading）：延迟加载非必要的模块，在需要时再进行异步加载，减少初始加载时间。
- 缓存利用：使用文件名哈希或chunkhash等机制，利用浏览器缓存，避免重复加载资源。
- 并行构建：使用多线程或进程池等技术，加快构建速度。
- 使用Webpack插件：如UglifyJsPlugin、OptimizeCSSAssetsPlugin等，进行代码压缩和优化。
- 配置优化：合理配置Webpack的各项参数，如devtool、mode、resolve等，以提高打包性能和效率。

### 5. Vue中的路由懒加载是什么？为什么要使用它？

在Vue中，路由懒加载是一种优化技术，用于延迟加载应用程序的路由组件。传统的路由配置方式会将所有的路由组件打包在一个文件中，导致初始加载时下载的代码量较大，影响页面加载速度。而路由懒加载能够将路由组件按需加载，只有在需要渲染特定路由时才会加载相应的组件。

使用路由懒加载可以带来以下好处：

1. 减少初始加载时间：将路由组件拆分为多个异步加载的文件，可以减小初始加载的文件体积，加快页面的加载速度。只有当用户访问到对应的路由时，才会去加载相应的组件，提升了网页的整体性能和用户体验。
2. 减少资源浪费：如果某些路由组件用户很少访问或可能永远不会访问到，通过懒加载可以避免预加载这些组件，从而减少了资源的浪费。
3. 优化代码拆分：懒加载使得代码按需加载，使得每个页面只加载当前所需的代码，而无需一次性加载全部的路由组件。这有助于优化代码拆分，提高应用的可维护性和可扩展性。

在Vue中使用路由懒加载非常简单，可以使用import()函数来动态导入组件。例如：

```javascript
const Home = () => import('@/views/Home.vue');
const About = () => import('@/views/About.vue');
const Contact = () => import('@/views/Contact.vue');

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
  { path: '/contact', component: Contact },
];
```

在上面的代码中，import()函数会将对应的组件进行按需加载。当用户访问到某个路由时，才会触发相应的组件加载。



### 6. 怎么二次封装一个Vue组件？

要二次封装一个Vue组件，可以按照以下步骤进行操作：

1. 创建基础组件：首先，创建一个基础组件，包括模板、样式和逻辑。这个组件应该实现基本的功能，并提供一些可配置的 props。
2. 提取可复用的代码：在基础组件中，找出一些可以被复用的代码段，例如公共的计算属性、方法或样式等。将这些代码段提取出来，作为可配置项或函数，以便在二次封装过程中进行灵活调用。
3. 设计可配置项：根据基础组件的需求，设计一些可配置的 props，通过这些 props 可以控制组件的行为和样式。确保这些 props 能满足不同场景下的使用需求。
4. 组合基础组件：在二次封装的组件中，引入并使用基础组件，并根据需要添加额外的布局、样式和功能。通过传递 props 和监听事件，将基础组件与封装组件进行交互。
5. 扩展功能：如果需要，可以在二次封装的组件中添加一些额外的功能，如自定义事件、插槽等，以增加组件的灵活性和可扩展性。
6. 提供文档和示例：为了方便其他开发人员使用二次封装的组件，提供清晰的文档和示例代码是很重要的。文档应包括组件的 props、事件、插槽等详细说明，示例代码可以展示组件的用法和效果。
7. 进行测试和优化：在完成二次封装后，进行组件的测试，确保其功能和兼容性。根据实际使用情况，不断优化组件的性能和用户体验

假设我们要封装一个名为CustomButton的按钮组件，它具有以下功能：

- 可以接收外部传入的文本内容和样式类名；
- 点击按钮时触发自定义事件，并将相应的数据传递给父组件。

下面是一个简单的示例代码：

```vue
<template>
  <button :class="className" @click="handleClick">
    {{ buttonText }}
  </button>
</template>

<script>
  export default {
    name: 'CustomButton',
    props: {
      buttonText: {
        type: String,
        required: true
      },
      className: {
        type: String,
        default: ''
      }
    },
    methods: {
      handleClick() {
        // 点击按钮时触发自定义事件，并传递相应的数据
        this.$emit('custom-click', this.buttonText);
      }
    }
  }
</script>

<style scoped>
  /* 自定义按钮样式 */
  button {
    /* 样式规则 */
  }
</style>
```

在这个例子中，我们首先创建了一个基础组件CustomButton，它接收两个props：buttonText和className。buttonText用于显示按钮上的文本内容，className用于设置按钮的样式类名。

当点击按钮时，调用handleClick方法来触发自定义事件custom-click，并将buttonText作为参数传递给父组件。

在使用这个组件时，可以按照以下方式进行二次封装：

```vue
<template>
  <div>
    <CustomButton
      buttonText="Click Me"
      className="custom-button"
      @custom-click="handleButtonClick"
      />
  </div>
</template>

<script>
  import CustomButton from './CustomButton.vue';

  export default {
    name: 'ExampleComponent',
    components: {
      CustomButton
    },
    methods: {
      handleButtonClick(buttonText) {
        // 处理按钮点击事件，获取传递的数据
        console.log('Button clicked:', buttonText);
      }
    }
  }
</script>
```

在这个二次封装的组件中，我们使用CustomButton作为子组件，并通过props来配置按钮的文本内容和样式类名。同时，监听custom-click事件来处理按钮的点击事件，在handleButtonClick方法中获取传递的数据并进行相应的处理。





### 7. 瀑布流原理

瀑布流是一种网页布局方式，常用于图片展示等场景。其原理是将内容按照列的方式排列，每一列的高度根据内容的实际高度动态调整，使得整个页面呈现出类似瀑布流般的效果。

瀑布流的实现过程如下：

1. 首先确定要展示的列数，可以根据页面宽度和元素宽度计算得出。
2. 创建相应数量的列，并对每一列进行定位，使其水平排列。
3. 将待展示的内容逐个放入最短的那一列中，以保持整体的平衡。
4. 每当一个新的元素被添加到某一列后，更新该列的高度，以反映新的高度。
5. 用户滚动页面时，根据需要加载更多的内容，并重复以上步骤。

### 8. 大数据场景下表格方案如何处理

在大数据场景下，处理表格数据通常需要考虑以下几个方面：

- 数据量：大数据场景下的表格可能包含成千上万行的数据，因此需要考虑分页加载数据或者使用虚拟滚动技术，避免一次性加载所有数据。
- 性能优化：针对大量数据的查询和排序需求，可以使用索引、分区、缓存等技术来提高查询速度和响应时间。
- 数据展示：对于大数据量的表格，可以采用分页或滚动加载的方式进行展示，以减少页面加载时间，并提供搜索和筛选功能以便用户快速找到所需数据。
- 可视化：为了更好地理解和分析大数据，可以使用数据可视化工具，如图表、图形等，将数据以更直观的方式呈现给用户。

### 9. 浏览器返回资源之后的渲染过程

当浏览器返回资源（如 HTML、CSS、JavaScript 文件等）后，它会按照以下步骤进行渲染：

1. 解析HTML：浏览器解析HTML文档，构建DOM树（Document Object Model），表示文档结构。
2. 构建渲染树：浏览器将DOM树和CSS样式（如果存在）合并，生成渲染树（Render Tree），其中只包含需要显示的节点。
3. 布局计算：浏览器对渲染树进行布局计算，确定每个节点在屏幕上的位置和大小。
4. 绘制内容：浏览器使用绘图API将渲染树中的节点绘制到屏幕上，形成一帧。
5. 渲染完成：浏览器不断重复上述步骤，直到渲染树中的所有帧都被绘制完成。

### 10. vue router的两种方式的原理

Vue Router提供了两种路由方式：Hash 模式和 History 模式。

- Hash 模式：在URL中使用哈希值（#）来作为路由地址的标识。通过监听URL的变化事件，当URL的哈希值发生变化时，Vue Router会根据哈希值匹配相应的组件，并进行页面跳转。这种方式不会触发浏览器的页面刷新，适用于不需要服务器端配置的情况。
- History 模式：利用HTML5的History API，修改浏览器的历史记录，使得URL可以无需哈希值，直接使用真实的路径来表示路由地址。当URL的路径发生变化时，

Vue Router会监听浏览器的导航事件，并根据路径匹配相应的组件进行页面跳转，同时通过History API来修改浏览器历史记录，使得前进和后退按钮可以正常工作。这种方式在URL上更加友好，但需要服务器端配置支持，以确保在刷新页面或直接访问路由时能够正确地返回对应的内容。

### 11. http的头信息 keep-alive

HTTP协议中的"keep-alive"头信息实现了持久连接（Persistent Connection）的功能。它通过在请求头中添加"Connection: keep-alive"字段，告诉服务器在响应完成后保持TCP连接打开，以便后续的请求可以重用同一个连接。

使用持久连接可以带来以下优点：

- 减少连接建立的开销：保持TCP连接避免了每次请求都需要重新建立和关闭连接的消耗，减少了网络延迟和服务器资源的浪费。
- 提高性能和效率：多个请求可以共享同一个连接，提高了并发请求的效率，减少了网络拥塞。
- 减少资源消耗：对于具有大量静态资源的网站，使用持久连接可以减少服务器的负载和资源占用。

### 12. vue和react的区别

Vue和React是两个流行的JavaScript前端框架，它们有以下一些区别：

- 学习曲线：Vue相对来说更易学，因为它提供了模板语法和逐渐增加的功能。React则更加灵活，但需要更多的理解和学习，因为它使用JSX语法和函数式编程的思维方式。
- 组件化开发：Vue将组件作为核心概念，提供了更直观的组件化开发体验。React也支持组件化开发，但更注重于构建UI库而不是完整的框架。
- 数据绑定方式：Vue使用双向数据绑定，通过v-model指令实现数据的双向绑定。React采用了单向数据流，父组件通过Props传递数据给子组件，并通过回调函数的方式进行交互。
- 生态系统：React拥有庞大的生态系统和活跃的社区，有很多第三方库和工具可以选择。Vue的生态系统也在迅速发展，但相对来说规模较小一些。
- 渲染方式：Vue使用模板语法配合虚拟DOM的方式进行渲染，而React只使用JSX语法，并通过虚拟DOM实现高效的渲染。

### 13. Vue3 + TypeScript 有什么优势？

Vue3与TypeScript的结合带来了以下几个优势：

1. 类型检查：TypeScript为Vue3提供了静态类型检查的能力，可以在开发过程中捕获潜在的错误和问题，提高代码的可靠性和可维护性。
2. 更好的开发体验：通过使用TypeScript，可以享受到更好的开发工具支持，如编辑器的智能提示、自动补全等，以及错误检查和重构功能，提升开发效率。
3. 更丰富的类型定义：Vue3使用TypeScript重新编写了大部分的类型定义文件，提供了更丰富的类型定义，使得开发者可以更准确地知道组件的props、事件等相关信息。
4. Composition API 支持：Vue3引入了Composition API，它提供了一种新的组织组件逻辑的方式。使用TypeScript可以更好地对Composition API进行类型推导和约束，提供更好的代码提示和可读性。
5. 更好的扩展性和维护性：TypeScript的静态类型检查有助于减少错误和改进代码的可维护性。通过类型检查，可以更早地发现问题并做出修复，同时还可以更安全地进行重构和修改代码。

总而言之，Vue3结合TypeScript可以提供更好的开发体验、更高的代码可靠性和可维护性，使得在大型项目中使用Vue变得更加可靠和高效。

### 14. Vue2 和 Vue3 的区别



Vue2和Vue3在以下几个方面有明显的区别：

1. 性能优化：Vue3对渲染性能进行了优化，利用Proxy代理和观察者追踪机制的改进，提高了组件的更新速度和响应性能。
2. Composition API：Vue3引入了Composition API，它允许开发者根据逻辑功能组织代码，而不是按照选项（data、methods、computed等）进行分组。这样可以更好地重用和组合逻辑，使得代码更具可读性和可维护性。
3. 更小的包体积：Vue3通过使用Tree-Shaking技术以及模块的重构和删除，实现了更小的包体积，减少了额外的运行时文件大小。
4. 更好的 TypeScript 支持：Vue3对TypeScript的支持更加全面，重新编写了类型定义文件，并提供了更丰富的类型推导和约束。
5. 兼容性：Vue3移除了一些Vue2的旧有特性和API，因此在迁移到Vue3时，需要注意一些不兼容的变化和调整。
6. 响应式原理：Vue3使用了Proxy代理对象来实现响应式，相比Vue2中的Object.defineProperty，Proxy提供了更高效和全面的观察者机制。

需要注意的是，由于Vue2和Vue3有一些重要的区别，在迁移到Vue3时可能需要进行一些代码的调整和修改。

### 15. 浏览器的双向通信有哪些方式？

浏览器的双向通信可以通过以下几种方式实现：

1. Ajax：使用AJAX技术可以实现浏览器与服务器之间的异步通信。通过发送HTTP请求并接收响应，可以在不刷新页面的情况下进行数据的交换和更新。
2. WebSockets：WebSockets提供了浏览器与服务器之间的全双工通信能力。通过WebSocket协议，可以建继续回答浏览器的双向通信有哪些方式：
3. WebSockets：WebSockets提供了浏览器与服务器之间的全双工通信能力。通过WebSocket协议，可以建立持久的连接，并实现实时的双向数据传输。这使得服务器可以主动向浏览器发送数据，而不需要浏览器发起请求。
4. Server-Sent Events（SSE）：Server-Sent Events是一种基于HTTP的单向通信机制，用于从服务器向客户端推送事件流。通过使用EventSource对象，浏览器可以接收来自服务器的事件消息，实现服务器主动向浏览器推送数据。
5. WebRTC：WebRTC（Web Real-Time Communication）是一种用于实时音视频通信的开放标准。它提供了点对点的双向通信，可以在浏览器之间直接传输音视频和数据流，而无需经过服务器中转。
6. postMessage API：postMessage API允许在不同的窗口或浏览器之间发送消息。通过调用postMessage函数，可以跨域名、跨窗口进行双向通信。这在使用iframe嵌套页面或在不同窗口间进行通信时非常有用。
7. SharedWorker：SharedWorker是一种可在多个浏览器上下文（tabs、windows等）之间共享的后台线程。它可以与多个浏览器窗口进行通信，实现跨标签或跨窗口的双向通信。

这些方式提供了不同的技术和协议来实现浏览器与服务器之间的双向通信。具体选择哪种方式取决于应用场景和需求，以及对浏览器和服务器的支持程度。



### 16. 怎么分片传输和接收信息？

分片传输和接收信息是一种将大文件拆分成多个小片段进行传输的技术，以减少传输时间和提高网络效率。

在发送端，可以按照以下步骤进行分片传输：

1. 将要发送的大文件划分为固定大小的小片段（通常称为分片或数据包）。
2. 给每个分片分配唯一的标识符，并记录它们的顺序。
3. 使用网络传输协议（如TCP或UDP）将每个分片单独发送到接收端。

在接收端，可以按照以下步骤进行分片接收并重组信息：

1. 接收到分片后，根据标识符将它们重新排序。
2. 将这些分片逐个存储在内存中或者写入硬盘的临时文件。
3. 当所有分片都被接收后，根据顺序将它们合并成完整的文件。

在实现分片传输和接收信息时，需要注意以下事项：

- 分片大小的选择：分片的大小应该既满足网络传输的需求，又不会导致过多的分片，影响传输效率。
- 标识符的分配：为每个分片分配唯一的标识符，通常使用序号或哈希值来标识分片的顺序。
- 数据完整性检查：可以通过在每个分片中添加校验码（如CRC）来验证数据的完整性，以确保接收到的分片没有损坏或篡改。
- 错误处理和重传机制：如果某个分片在传输过程中丢失或出错，需要有相应的错误处理和重传机制，确保分片能够被成功接收。

### 17. 实现一个双向绑定

实现一个双向绑定需要以下几个步骤：

1. 在数据模型中定义需要绑定的属性，并初始化默认值。
2. 在视图中创建对应的输入框、复选框、下拉列表等表单元素，并将其与数据模型中的属性进行绑定。
3. 监听视图中绑定的元素的事件，如input事件、change事件等。
4. 在事件处理程序中获取用户输入的值，并将其更新到数据模型中的属性上。
5. 同时，当数据模型中的属性发生变化时，触发通知机制，更新绑定的视图。

具体实现双向绑定的方式有多种，以下是其中一种常见的方式：

- 使用观察者模式：在数据模型中定义一个观察者对象，用于保存绑定的属性和对应的依赖关系。在视图绑定时，将观察者对象作为中介，建立属性与视图之间的联系。当属性发生变化时，触发通知机制，通知所有依赖于该属性的视图进行更新。

### 18. 讲一下事件循环

事件循环是JavaScript中处理异步任务的一种机制，用于管理事件队列、执行回调函数和维护程序的执行顺序。

JavaScript是单线程的语言，即一次只能执行一个任务。为了处理异步任务（如定时器、网络请求、事件监听等），JavaScript引入了事件循环机制。

事件循环包含以下几个关键组件：

1. 调用栈（Call Stack）：用于存储函数调用的上下文和执行状态。当函数被调用时，会将其压入调用栈中执行，当函数执行完毕后，从调用
2. 任务队列（Task Queue）：用于存储异步任务的回调函数。当异步任务完成后，会将其对应的回调函数放入任务队列中等待执行。
3. 事件循环（Event Loop）：负责监控调用栈和任务队列，并根据规则进行任务的执行。它不断地检查调用栈是否为空，如果为空，则从任务队列中取出一个任务回调函数并放入调用栈中执行。

事件循环的执行过程如下：

1. 执行同步代码，将函数调用压入调用栈中执行。
2. 如果遇到异步任务（如setTimeout、网络请求等），将其回调函数放入任务队列中，不会立即执行。
3. 当所有同步代码执行完毕后，事件循环开始工作。
4. 事件循环首先检查调用栈是否为空，如果为空，则从任务队列中取出一个任务回调函数放入调用栈中执行。
5. 执行完任务回调函数后，再次检查调用栈是否为空，如果不为空，则继续执行调用栈中的下一个函数。
6. 循环以上步骤，直到调用栈和任务队列都为空。

需要注意的是，任务队列中的任务分为宏任务（macrotask）和微任务（microtask）。事件循环会先执行当前的微任务队列，然后再执行一个宏任务。微任务包括Promise的回调、MutationObserver的回调等，而宏任务包括setTimeout、setInterval、I/O操作等。



### 19. 前端安全问题有哪些，如何解决？

前端安全问题是指在前端开发中可能存在的安全隐患和攻击风险。以下是一些常见的前端安全问题：

- 跨站脚本攻击（XSS）：攻击者通过注入恶意脚本来获取用户敏感信息或篡改页面内容。

- - 解决方案：对用户输入进行合适的过滤和转义处理，使用内容安全策略（CSP）限制外部资源加载，避免直接执行不可信的用户输入。

- 跨站请求伪造（CSRF）：攻击者利用用户的身份，在用户不知情的情况下发送恶意请求。

- - 解决方案：使用随机令牌（CSRF Token）验证请求来源，限制跨域请求，设置同源策略。

- 点击劫持：攻击者将目标网页嵌入到一个透明的iframe中，并诱导用户点击，实现对目标网页的控制。

- - 解决方案：使用X-Frame-Options响应头阻止网页被嵌入到iframe中，或者使用JavaScript脚本进行自我保护。

- 数据泄露：未妥善处理敏感数据，或在前端代码中包含敏感信息。

- - 解决方案：合理设计前后端的数据传输和存储方式，对敏感信息进行加密保护，避免在前端暴露。

- 不安全的第三方库：使用未经审查或存在漏洞的第三方库，可能导致代码注入或其他安全问题。

- - 解决方案：仔细选择可信任的第三方库，定期更新升级，及时修复已知漏洞。

要解决这些前端安全问题，开发人员应该保持对常见漏洞和攻击手法的了解，并采取相应的防范措施。同时，使用安全编码实践，如输入验证、输出转义、身份验证与授权、最小化权限等，可以有效提高前端应用的安全性。

### 20. HTTP和HTTPS的区别

HTTP（HyperText Transfer Protocol）和HTTPS（HTTP Secure）是两种不同的传输协议。

- HTTP：HTTP是一种用于在客户端和服务器之间传输信息的协议。它基于文本，使用明文传输数据，不提供加密和身份验证机制。因此，HTTP传输的数据在网络中容易被窃听、篡改或伪造。
- HTTPS：HTTPS是HTTP的安全版本。它在HTTP的基础上添加了SSL/TLS协议层，提供了加密和身份验证功能。HTTPS使用公钥加密来保证数据的机密性，并使用数字证书来验证服务器的身份。

主要区别如下：

- 安全性：HTTP不提供数据加密和身份验证，容易被窃听、篡改或伪造，而HTTPS通过SSL/TLS加密传输数据，保证了数据的安全性。
- 默认端口：HTTP使用80端口进行通信，而HTTPS使用443端口。这个区别使得服务器能够根据端口号判断使用的是HTTP还是HTTPS协议。
- 证书：HTTPS需要使用数字证书来验证服务器的身份。证书由可信任的第三方机构颁发，用于确认服务器的真实性和完整性。
- 性能：由于HTTPS需要进行加密解密操作，会增加一定的计算和网络开销，因此相比HTTP会稍微降低性能。

在现代网络环境下，为了保在现代网络环境下，为了保护用户的隐私和数据安全，使用HTTPS协议已成为互联网的标准做法。特别是涉及敏感信息（如个人账号、密码、支付信息等）传输的场景，使用HTTPS是必要的。

### 21. 讲述一下WebSocket

WebSocket是一种提供双向通信功能的协议，允许在客户端和服务器之间建立持久连接，实现实时数据传输。

与传统的HTTP请求-响应模式不同，WebSocket允许服务器主动向客户端发送数据，而不需要客户端发起请求。这种实时性的双向通信非常适用于实时聊天、实时游戏、股票交易等需要低延迟和高并发的场景。

WebSocket的特点包括：

- 建立持久连接：通过一次握手过程，在客户端和服务器之间建立持久连接，避免了每次通信都需要重新建立连接的开销。
- 双向通信：客户端和服务器可以互相发送数据，实现双向通信。
- 实时性：无需等待客户端的请求，服务器可以主动推送数据给客户端，实现实时数据传输。
- 更小的数据传输量：WebSocket使用二进制帧和消息格式，相比传统的HTTP请求头，传输量更小，减少了网络开销。

使用WebSocket的步骤如下：

1. 客户端发送一个HTTP请求到服务器，请求升级为WebSocket协议。
2. 服务器返回101状态码表示切换成功，建立WebSocket连接。
3. 客户端和服务器之间进行双向通信，可以通过send()方法发送消息，通过onmessage事件监听接收到的消息。

使用WebSocket需要注意以下几点：

- 协议支持：WebSocket需要客户端和服务器均支持WebSocket协议才能正常通信。
- 安全性：WebSocket协议默认使用ws://（非加密）的URL前缀，如果要实现加密传输，需要使用wss://（加密）的URL前缀，并使用SSL/TLS证书来保证数据安全。
- 兼容性：虽然现代浏览器普遍支持WebSocket，但仍然需要考虑兼容性问题，在不支持WebSocket的环境下提供其他替代方案。

### 22. HTTP响应状态码

HTTP响应状态码是服务器在处理请求后返回给客户端的一种标识，用于告知客户端请求的处理情况。常见的HTTP响应状态码包括：

- 200 OK：请求成功，服务器正常返回所请求的资源。
- 301 Moved Permanently：永久重定向，请求的资源已永久移动到新的URL。
- 302 Found / 307 Temporary Redirect：临时重定向，请求的资源临时移动到新的URL。
- 400 Bad Request：请求无效，服务器无法理解客户端发送的请求。
- 401 Unauthorized：未授权，需要进行身份验证才能访问该资源。
- 403 Forbidden：禁止访问，服务器拒绝客户端访问所请求的资源。
- 404 Not Found：未找到，服务器无法找到所请求的资源。
- 500 Internal Server Error：服务器内部错误，无法完成请求的处理。



### 23. 前端本地存储

前端本地存储是指在浏览器端将数据保存在用户的本地设备上，以实现临时或持久化的数据存储。常见的前端本地存储技术包括：

- Cookies：Cookies是一种小型文本文件，通过在浏览器中存储键值对的方式进行本地存储。Cookies可以设置过期时间，并随着每次HTTP请求发送到服务器端。
- Web Storage API：Web Storage API提供了两种存储方式：sessionStorage和localStorage。它们都是基于键值对的存储机制，可以使用setItem()、getItem()和removeItem()等方法进行操作。sessionStorage用于临时会话存储，而localStorage用于长期持久化存储。
- IndexedDB：IndexedDB是一种高级的客户端数据库，可用于在浏览器中存储大量结构化数据。它提供了一个异步的API，可以进行复杂的查询和事务操作。
- Cache API：Cache API允许开发者以编程方式缓存网络请求的响应，从而实现离线访问和更快的加载速度。

这些前端本地存储技术各有特点和适用场景。开发人员可以根据需求选择合适的存储方式来实现数据的本地存储和读取。

### 24. 闭包

闭包（Closure）是指在函数内部创建并返回另一个函数，该函数可以访问父级函数作用域中的变量和参数。通过闭包，函数可以保留对其定义时上下文环境的引用，即使这个环境已经不存在。

闭包的特点包括：

- 内层函数可以访问外层函数的变量和参数。
- 闭包可以在外层函数执行完毕后仍然访问和操作外层函数的变量。
- 外层函数的变量不会被垃圾回收机制回收，直到闭包不再被引用。

使用闭包可以实现一些高级的编程技巧，例如：

- 封装私有变量：通过闭包可以创建私有变量，只有通过内部函数才能访问和修改。
- 实现柯里化函数：柯里化是一种将多参数函数转换为接收一个参数的函数序列的技术，通过闭包可以实现柯里化函数。
- 延迟执行：通过闭包可以实现延迟执行函数，在适当的时间执行预定的操作。

需要注意的是，由于闭包会保留对外部函数的引用，如果使用不当，可能导致内存泄漏问题。因此，在使用闭包时需要注意及时释放不再使用的资源，避免造成性能问题。

### 25. Vue性能优化

在Vue中，可以采取以下几种手段来进行性能优化：

1. 延迟加载组件：

- - 使用异步组件：将一些不必要立即加载的组件定义为异步组件，在需要时再按需加载。可以使用import()函数或Vue的lazy-loading特性实现。

1. 列表渲染优化：

- - 使用key属性：在v-for循环中，为每个列表项提供稳定的唯一标识（例如使用key属性），以便Vue能够高效地复用和更新元素。
- 使用`<transition-group>`：当有多个动态列表项需要频繁增删时，使用`<transition-group>`可以让Vue更高效地处理动画和过渡效果。

1. 虚拟滚动：

- - 对于长列表或大数据量的情况，使用虚拟滚动技术可以只渲染可见部分，减少DOM节点数量，提升性能。可以使用第三方库如vue-virtual-scroller、vue-virtual-scroll-list等。

1. 懒加载图片：

- - 图片懒加载：只在图片进入可视区域时才加载图片资源，可以使用第三方库如vue-lazyload来实现延迟加载图片，减少页面初始加载时间。

1. 避免不必要的渲染：

- - 使用v-if和v-show：根据条件动态渲染或显示组件，避免不必要的组件渲染。
- 使用shouldComponentUpdate或watcher：在Vue组件中，通过手动判断状态变化来决定是否进行重新渲染。

1. 组件缓存：

- - 使用`<keep-alive>`：对于频繁使用的组件，可以使用`<keep-alive>`标签进行缓存，提高组件的复用性和响应性能。

1. 利用CDN加速：

- - 将静态资源（如Vue库、第三方依赖等）托管到CDN上，可以减少加载时间并提高用户体验。

1. 代码优化：

- - 进行代码拆分和按需加载：将大型应用拆分为多个模块，按需加载，减少初始加载的代码量。
- 使用Vue的生命周期钩子函数：合理利用Vue的生命周期钩子函数，在适当的时机执行相关操作，避免不必要的计算和渲染。

1. 服务端渲染（SSR）：

- - 对于需要更高性能和SEO的场景，可以考虑使用Vue的服务端渲染技术，将页面的初始化渲染工作放在服务器端完成，减少客户端的工作量。



### 26. 前端监控



前端监控主要包括数据采集、数据处理与存储、数据可视化与报表以及隐私保护等步骤。

1. 数据采集：

- - 监听错误：通过监听JavaScript的错误事件（如window.onerror）捕获前端应用发生的异常信息，包括错误消息、堆栈信息等。
- 监测性能：使用Performance API获取页面加载时间、资源加载时间、渲染性能等关键指标。利用Navigation Timing API和Resource Timing API来收集网络请求的详细信息。
- 监视用户行为：通过埋点技术，在关键操作点插入代码，并记录用户的点击、滚动、表单提交等行为。

1. 数据处理与存储：

- - 处理数据：对采集到的数据进行处理和过滤，提取关键信息，如错误类型、发生频率、用户环境等。
- 存储数据：将处理后的数据存储到日志系统、数据库或第三方服务中，以便后续分析和查询。

1. 数据可视化与报表：

- - 数据展示：将处理后的数据以可视化的方式呈现，例如使用图表、表格等形式展示错误数量、性能指标曲线等。
- 报表分析：通过报表工具或自行开发的界面，对采集到的数据进行分析，发现问题和优化点。

1. 隐私保护：

- - 数据匿名化：在采集和存储数据时，去除或加密敏感信息，确保用户隐私得到保护。
- 遵守法律法规：遵循相关的法律法规和隐私政策，保证合法、合规地进行前端监控。

在前端监控中，常见的方法有以下几种：

1. 错误监控：

- - 使用全局错误处理器：通过注册window.onerror事件来监听全局错误，捕获JavaScript异常，并记录错误信息和堆栈轨迹。
- 捕获Promise异常：使用window.addEventListener('unhandledrejection', callback)来捕获未处理的Promise异常。
- 监听网络请求错误：通过XMLHttpRequest或Fetch API的错误事件来捕获网络请求的错误状态码。

1. 性能监控：

- - Performance API：利用Performance API提供的接口，如performance.timing、performance.getEntries()等，获取页面加载时间、资源加载时间、重定向时间等性能指标。
- Navigation Timing API：使用Navigation Timing API获取详细的导航和加载性能数据，如DNS查询时间、TCP连接时间等。
- Resource Timing API：利用Resource Timing API获取每个资源加载的详细性能数据，如资源的下载时间、大小等。

1. 用户行为监控：

- - 埋点技术：在关键操作点插入代码，通过监听事件（如点击、滚动、表单提交等）来记录用户行为，将相关数据发送到服务器进行分析。
- 用户行为分析工具：使用第三方工具（如Google Analytics、Hotjar等）来跟踪用户行为和交互，收集点击热力图、用户路径分析等数据。

1. 实时监控：

- - WebSocket：使用WebSocket技术实现实时数据传输，并在服务器端进行处理和分析，实时监控应用的性能指标和错误信息。
- Server-Sent Events (SSE)：使用SSE技术，通过单向通信从服务器获取实时数据，适合实时更新数据、日志等场景。

1. 性能优化工具：

- - Lighthouse：一个开源工具，可对网站进行全面的性能评估，并提供改进建议。
- WebPageTest：一个在线的性能测试工具，可以模拟不同地点和设备进行性能测试，并生成详细的加载时间和资源分析报告。
- Chrome DevTools：Chrome浏览器自带的开发者工具，提供了丰富的性能监控和分析功能，如Performance和Network面板。





### 27. Vue.nextick原理

    1. 把回调函数放入`callbacks`等待执行
    2. 通过pending判断是不是已经执行过，避免重复执行
    3. 将执行函数放到微任务或者宏任务中，根据当前环境不断降级处理，Promise.then =》MutationObserver =》setImmediate =》setTimeout
    4. 事件循环到了微任务或者宏任务，执行函数依次执行`callbacks`中的回调



### 28. 纯函数和函数柯里化

纯函数的定义：

1. 确定的输入，会产生确定的输出
2. 不会产生副作用
